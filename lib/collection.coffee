_       = require 'underscore'
helper  = require './helper'
Driver  = require './driver'
util    = require 'util'

# Integration with Model.
class Driver.Collection
  constructor: (@name, @options, @db) ->

  drop: (callback) ->
    @connect callback, (nCollection) =>
      @db.info "drop #{@name}"
      nCollection.drop callback

  # CRUD.
  create: (obj, options..., callback) ->
    options = options[0] || {}

    # Adding default options.
    options = _.extend {safe: Driver.safe}, options

    # Generate custom id if specified.
    if !helper.getId(obj) and Driver.generateId
      idGenerated = true
      helper.setId obj, helper.generateId()

    # Support for Model.
    doc = if obj.isModel then obj.toMongo() else obj

    # Logging.
    @db.info "#{@name}.create #{util.inspect(doc)}, #{util.inspect(options)}"

    # Saving.
    @connect callback, (nCollection) =>
      mongoOptions = helper.cleanOptions options
      doc = helper.convertDocIdToMongo doc
      nCollection.insert doc, mongoOptions, (err, result) =>
        doc = helper.convertDocIdToDriver doc

        # Cleaning autogenerated id if object not saved.
        helper.setId obj, undefined if err and idGenerated

        # Setting new id.
        helper.setId obj, helper.getId(doc) unless err

        # In case of model we should result should be boolean value.
        if obj.isModel
          result = not err
        else
          result = result[0] unless err

        # For models we intercept unique index errors and store it as model errors.
        if obj.isModel and err and (err.code in [11000, 11001]) and obj.addError?
          obj.addError base: 'not unique'
          err = null

        callback err, result

  update: (args..., callback) ->
    [first, second, third] = args
    if first.isModel
      id = helper.getId(first) || throw new Error "can't update model without id!"
      [selector, obj, options] = [{id: id}, first, (second || {})]
    else
      [selector, obj, options] = [first, second, (third || {})]
    throw new Error "data object for update not provided!" unless obj

    # Support for Model.
    doc = if obj.isModel then obj.toMongo() else obj

    # Adding default options. Because :multi works only with $ operators,
    # we need to check if it's applicable.
    options = if _(_(doc).keys()).any((k) -> /^\$/.test(k))
      _.extend {safe: Driver.safe, multi: Driver.multi}, options
    else
      _.extend {safe: Driver.safe}, options

    # Logging.
    [ss, ds, os] = [util.inspect(selector), util.inspect(doc), util.inspect(options)]
    @db.info "#{@name}.update #{ss}, #{ds}, #{os}"

    # Saving.
    @connect callback, (nCollection) =>
      mongoOptions = helper.cleanOptions options
      selector = helper.convertSelectorId selector
      doc = helper.convertDocIdToMongo doc
      nCollection.update selector, doc, mongoOptions, (args...) ->
        doc = helper.convertDocIdToDriver doc
        callback args...

  delete: (first, options..., callback) ->
    options = options[0] || {}
    selector = if first.isModel
      id = helper.getId(first) || throw new Error "can't delete model without id!"
      {id: id}
    else
      first

    # Adding default options.
    options = _.extend {safe: Driver.safe}, options

    # Logging.
    @db.info "#{@name}.delete #{util.inspect(selector)}, #{util.inspect(options)}"

    # Saving.
    @connect callback, (nCollection) =>
      mongoOptions = helper.cleanOptions options
      selector = helper.convertSelectorId selector
      nCollection.remove selector, mongoOptions, callback

  save: (obj, options..., callback) ->
    method = if helper.getId(obj) then 'update' else 'create'
    @[method] obj, options..., callback

  # I prefer names `create` and `delete`, but
  # You still can use `insert` and `remove`.
  insert: (args...) -> @create args...
  remove: (args...) -> @delete args...

  # Querying.

  cursor: (args...) -> new Driver.Cursor @, args...

  find: (args...) -> @cursor args...

  # Indexes.

  ensureIndex: (args..., callback) ->
    @db.info "#{@name}.ensureIndex #{util.inspect(args)}"
    @connect callback, (nCollection) ->
      args.push callback
      nCollection.ensureIndex args...

  dropIndex: (args..., callback) ->
    @db.info "#{@name}.dropIndex #{util.inspect(args)}"
    @connect callback, (nCollection) ->
      args.push callback
      nCollection.dropIndex args...

  connect: (callback, next) ->
    @db.connection.connectToCollection @db.name, @db.options, @name, @options, callback, next

# Making cursor's methods available directly on collection.
methods = [
  'first', 'all', 'next', 'close', 'count', 'each'

  'limit', 'skip', 'sort', 'paginate', 'snapshot', 'fields', 'tailable',
  'batchSize', 'fields', 'hint', 'explain', 'timeout'
]
for method in methods
  do (method) ->
    Driver.Collection.prototype[method] = (args...) ->
      @cursor()[method] args...